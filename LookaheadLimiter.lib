/*
 *  Copyright (C) 2014 Bart Brouns
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; version 2 of the License.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 */

/*some building blocks where taken from or inspired by compressor-basics.dsp by Sampo Savolainen*/

declare name      "LookAheadLimiter";
declare author    "Bart Brouns";
declare version   "0.1";
declare copyright "(C) 2014 Bart Brouns";

import ("music.lib");  //for linear2db

//todo: mid-side, auto-release

currentLevel(x)     = ((abs(x)):linear2db);
currentdown(x)      = 0-(((currentLevel(x))-threshold):max(0));

// smoothing function, 0 attack, release coefficient "r" and signal x
releaseEnv(r, x) = x:(env(r))~_
with {
    env (r, prevx, x)= select2( (x > prevx), x, (x*r)+(prevx * (1-r))     );
};

time_ratio_release(t) = exp(1) / ( t * SR * time_ratio_target_rel );

Lookahead(x,lastdown) =
variable_hold,
attackGR
:min
with {
    // this one should be more efficient: fixed hold time
    fixed_hold = ( 0:seq(i,maxHoldTime,(currentdown(x)@(i):max(lastdown)),_: min ));
    // yet this one is more efficient: variable hold time
    variable_hold =
      0:seq(i,maxHoldTime,
       (((i+1)>(maxHoldTime-holdTime))*(currentdown(x)@(i):max(lastdown))),_: min 
      );
    attackGR =
       0: seq(i,maxAttackTime,
         (currentdown(x)@((i+1-maxAttackTime+maxHoldTime))+lastdown)*(((i+1)/maxAttackTime):attackShaper),_: min
       )-lastdown;
    attackShaper(x)= tanh(x:pow(attack:attackScale)*(attack*5+.1))/tanh(attack*5+.1);
    //attackShaper(x)= tanh(x:pow(attack:attackScale)*mult)/tanh(mult);
    //attackShaper(x)= x:pow(attack:attackScale);
    attackScale(x) = (x+1):pow(7); //from 0-1 to 1-128, just to make the knob fit the aural experience better
    };
    //tanh(x^(32)*20)/tanh(20)

LookaheadPar(x,lastdown) = 
( par(i,maxHoldTime,(((i+1)>(maxHoldTime-holdTime))*(currentdown(x)@(i):max(lastdown)))): seq(j,(log(maxHoldTime)/log(2)),par(k,maxHoldTime/(2:pow(j+1)),min))),
( par(i,maxAttackTime, currentdown(x)@((i+1-maxAttackTime+maxHoldTime):max(0))*(((i+1)/maxAttackTime):attackShaper)): seq(j,(log(maxAttackTime)/log(2)),par(k,maxAttackTime/(2:pow(j+1)),min)))
:min
with {
    //attackShaper(x)= x:pow(attack:attackScale);//atan((gainHS+0.0001)*128*x)/atan((gainHS+0.0001)*128);
    attackShaper(x)= tanh(x:pow(attack:attackScale)*(attack*5+.1))/tanh(attack*5+.1);
    attackScale(x) = (x+1):pow(7); //from 0-1 to 1-128, just to make the knob fit the aural experience better
}
;

// smoothing function, attack coefficient "a", release coefficient "r" and signal x
SMOOTH(a, r,  x) = 
	((x     *      select2( (x < _), a, r )) + 
	(_ * (1 - select2( (x < _), a, r)))) ~ (_<:_,_,_);


/*rateLimiter(minRateDecay,prevx,x) = prevx+newtangent:min(0)*/
/*with {*/
    /*newtangent  = select2(tangent>0,minus,plus);*/
    /*tangent     = x- prevx;*/
    /*plus        = tangent*((abs(avgChange):mymeter*-1):db2linear):min(minRateDecay);*/
    /*minus       = tangent;// if you have to go down, you have to go down!*/
    /*avgChange   = (abs((tangent)-(tangent@1)):integrate(IM_size)*decayMult:_+1:pow(decayPower)-1)/200:SMOOTH(attackRel,0.0008):tanh*changeScale;*/
       /*//select2(abs(tangent)>maxRate,tangent,maxRate);*/
    /*integrate(size,x) = delaysum(size, x)/size;*/
    /*delaysum(size) = _ <: par(i,rmsMaxSize, @(i)*(i<size)) :> _;*/
    /*};*/

rateLimiter(minRateDecay,prevx,x) = prevx+newtangent:min(0)
with {
    newtangent  = select2(tangent>0,minus,plus);
    tangent     = x- prevx;
    plus        = (tangent*speed):max(minRateDecay);
//:min(minRateDecay)
    minus       = tangent;// if you have to go down, you have to go down!
    speed       = abs(select2(prevx<avgLevel,aboveAvg,belowAvg)):min(1):mymeter;
    avgLevel    = prevx:SMOOTH(attackRel,decayRel):avgMeter;
    belowAvg    = ((abs(x - avgLevel ) )*decayMult:_+1:pow(decayPower)-1)/200:tanh:pow(belowSpeed);
    aboveAvg    = aboveSpeed;
    //avgChange   = (abs(x-(integrate(IM_size,prevx):SMOOTH(attackRel,decayRel)))*decayMult:_+1:pow(decayPower)-1)/200:tanh*changeScale;
       //select2(abs(tangent)>maxRate,tangent,maxRate);
    integrate(size,x) = delaysum(size, x)/size;
    delaysum(size) = _ <: par(i,rmsMaxSize, @(i)*(i<size)) :> _;
    };

/*rateLimiter(minRateDecay,prevx,x) = prevx+newtangent:min(0)*/
/*with {*/
    /*newtangent  = select2(tangent>0,minus,plus);*/
    /*tangent     = x- prevx;*/
    /*plus        = tangent*((abs(avgChange):mymeter*-1):db2linear):min(minRateDecay);*/
    /*minus       = tangent;// if you have to go down, you have to go down!*/
    /*avgChange   = (tangent:nrSignChange(IM_size)*decayMult+1:pow(decayPower)-1)/200:SMOOTH(attackRel,0.0008):tanh*changeScale;*/
       /*//select2(abs(tangent)>maxRate,tangent,maxRate);*/
    /*nrSignChange(size)  = _ <: par(i,rmsMaxSize, signChange(i,size)) :> _/size;*/
    /*//signChange(i,x) = ( ((x@(i)>0) && (x@(i+1)<0)));*/
    /*signChange(i,size,x) = ( ((x@(i):max(0)) * (x@(i+1)<=0)) + ((x@(i):min(0)*-1) * (x@(i+1)>0)) ) * (i<size);*/
	/*integrate(size,x) = delaysum(size, x)/size;*/
    /*delaysum(size) = _ <: par(i,rmsMaxSize, @(i)*(i<size)) :> _;*/
    /*};*/

time_ratio_target_atk = 8.0;
time_ratio_attack(t) = exp(1) / ( t * SR * time_ratio_target_atk );

rateLimit = ( rateLimiter(minRateDecay) ~ _ );

minRateDecay   = (hslider("[2]min decay[unit:dB/s][tooltip: ]", 6, 0.001, 60 , 0.001)/SR);
decayMult      = (hslider("[3]decayMult[tooltip: ]", 0.2 , 0, 10 , 0.001)*100);
decayPower     = (hslider("[4]decayPower[tooltip: ]", 2, 0, 5 , 0.001));
IM_size        = (hslider("[5]IM_size[tooltip: ]",256, 1,   rmsMaxSize,   1)*44100/SR); //0.0005 * min(192000.0, max(22050.0, SR));
belowSpeed     = hslider("[6]belowSpeed[tooltip: ]", 20, 1, 20,   0.001);
aboveSpeed     = hslider("[7]aboveSpeed[tooltip: ]", 0.1, 0, 1,   0.001)*0.001;
attackRel      = (time_ratio_attack(hslider("[8] Attack [unit:ms]   [tooltip:  ]", 2.5, 0.001, 300, 0.001)/1000)) ;
decayRel       = (time_ratio_attack(hslider("[9] Decay [unit:ms]   [tooltip:  ]", 500, 0.001, 500, 0.001)/1000)) ;

linearXfade(x,a,b) = a*(1-x),b*x : +;

limiter(x) = (Lookahead(x):releaseEnv(logRelease))~_:meter:db2linear *x@maxHoldTime;

gainComputer(x) = (Lookahead(x):releaseEnv(logRelease):rateLimit)~_;
//gainComputer(x) = (Lookahead(x):releaseEnv(logRelease)<:(_,rateLimit):linearXfade((link*-1)+1))~_<:(_,rateLimit):linearXfade(link);
//gainComputer(x) = (Lookahead(x)<:(releaseEnv(logRelease),rateLimit):linearXfade(link))~_;
//gainComputer(x) = (Lookahead(x):releaseEnv(logRelease))~_;

stereoGainComputerHalf (x,y,prevy) =
  (
    (((_,(_,(prevy:Lookahead(y)):min)):linearXfade(link)):releaseEnv(logRelease))
    ~(Lookahead(x)<:_,_)
  );

stereoGainComputer(x,y) = (stereoGainComputerHalf(x,y),stereoGainComputerHalf(y,x))~(_,_ <: !,_,_,!);



stereoLimiter(x,y)  = stereoGainComputer(x,y) : (((_:meter:db2linear)*x@maxHoldTime,((_:meter:db2linear)*y@maxHoldTime)));

//faust2jaqt -t 999999 -time -sch -vs 4096 -mcd 8192 LookaheadLimiter.dsp  485.55s
//maxHoldTime = 1024 maxAttackTime = 1024
//jack: 78% CPU

//faust2jaqt -t 999999 -time -sch -vs 2048 -mcd 4096 LookaheadLimiter.dsp  485.55s
//maxHoldTime = 1024 maxAttackTime = 1024
//jack: 80% CPU
simpleStereoLimiter(x,y) = (((Lookahead(x):releaseEnv(logRelease)),(Lookahead(y):releaseEnv(logRelease))):min)~(_<:(_,_)):meter:db2linear<:(_*x@maxHoldTime,_*y@maxHoldTime);

//simpleStereoLimiter(x,y) = (LookaheadPar(x),LookaheadPar(y):min:releaseEnv(logRelease))~(_<:(_,_)):meter:db2linear<:(_*x@maxHoldTime,_*y@maxHoldTime);


//faust2jaqt -t 999999 -time -sch -vs 2048 -mcd 4096 LookaheadLimiter.dsp
//maxHoldTime = 1024 maxAttackTime = 1024
//jack: 52% CPU  169.49s
//maxHoldTime = 2048 maxAttackTime = 1024
//jack: 52% CPU 485.55s
naiveStereoLimiter(x,y) = (gainComputer(x),gainComputer(y)):min:meter:db2linear<:(_*x@maxHoldTime,_*y@maxHoldTime);




